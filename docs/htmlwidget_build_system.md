
# HTML Widget Build Environment

## Overview

(At least some of the) HTML Widgets written by Numbers International are maintained as coffeescript based nodejs projects that use gulp as a task manager. The twofold purpose(s) of these nodejs projects is to produce R HTMLWidget packages, and provide a framework for developing and testing the R htmlwidget pacakges. The [rhtmlTemplate](https://github.com/NumbersInternational/rhtmlTemplate) and [rhtmlPictographs](https://github.com/NumbersInternational/rhtmlPictographs) repositories are examples.

This document starts by listing the gulp `tasks` and why you would use them, then outlines the project structure and the purpose of each file. If this is all new to you you may want to start by jumping ahead to the `Terminology/Technology Breakdown` section, and then come back to the `gulp tasks` and `project structure` sections.

I will once again list the two most important things to remember:

1. The last thing you do before committing is run `gulp build` to ensure all the autogenerated files are up to date.
2. (With some exceptions) **ONLY EDIT THINGS IN these directories: `theSrc`, `docs` !!** Many of the other files are auto generated based on the contents of `theSrc`. As an example, if you edit `R/rhtmlTemplate.R` and then run `gulp build` your changes will be DELETED FOREVER!, because `R/rhtmlTemplate.R` is just a copy of `theSrc/R/htmlwidget.R`.

## Gulp Tasks

`gulp build` : simply by running `gulp build` the following tasks are performed :
 - transpile the coffeescript into ES5 javascript and place in the dist directories
 - compile the LESS into CSS and place in the dist directories
 - copy all images and other resources into the dist directories
 - generate the R docs from the R files and place into the man/ directory

`gulp serve` : simply by running `gulp serve` the following tasks are performed :
 - all of the build tasks above (except make docs and make R examples)
 - also produce a different transpiled version of the code that will load in a local browser window
 - in addition to the HTML Widget libraries, the local browser session will include a list of examples. This allows the developer to view how the effect of their most recent changes
 - gulp serve also starts a `watch` process. When used correctly this has a major impact on development velocity. Every save to the local file system will rebuild the project and then send a signal to the browser to reload the active page, so that the changes just made to the project are immediately visible.

### Why gulp serve ?

Adter reading the `gulp serve` description above, consider the following scenario where I begin to add feature X to my widget. I add an example called _**feature X WIP**_ to my [features.json](theSrc/features/features.json) file. I run `gulp serve`, and navigate to the _**feature X WIP**_ example. It doesn't work :(. This makes sense though because I haven't even written the code yet ! I make a series of changes to implement feature X, and I have a big monitor/two monitors so I have my browser and my IDE visible at the same time. Every time I save an update to my project files, gulp auto builds the code, and sends a reload signal to my browser. I am literally seeing the visual effects of my code changes in real time. _**This is really good**_.

## Project Structure

First a primer on R packages, specifically R htmlwidget packages. More detailed info can be found on the html widgets develop instro site : [http://www.htmlwidgets.orghttp://www.htmlwidgets.org/develop_intro.html](http://www.htmlwidgets.org/develop_intro.html). The following is a breakdown of the minimum set of files to create a HTMLWidget called Foo.

* **LICENSE** - License file
* **DESCRIPTION** - a R package manifest containing package name, version, author, etc.
* **NAMESPACE** - R import and export declarations
* **R/FOO.R** - the R code that defines the R API for the HTMLWidget
* **inst/htmlwidgets/FOO.js** - the javascript definition of the html widget
* **inst/htmlwidgets/FOO.yaml** - a manifest file that defines the javascript and css dependencies of the htmlwidget
* **inst/htmlwidgets/lib/DEPENDENCY.js** - a JS dependency, think jquery or d3. These must be listed in the YAML file.
* **inst/htmlwidgets/lib/STYLE.css** - CSS dependency

Given we use npm and package.json to manage our dependencies, and given we have a browser/ directory that supports the `gulp serve` workflow, maintaining our code in the structure outlined above is not really a good option. Instead, we choose to maintain all the source code in a directory called `theSrc` and use a gulp build process to automatically generate the R htmlwidget file structure above from the source in `theSrc`.

Even though the original/gold/working/active copy of all the src is in a folder called `theSrc`, we still check all the `compiled` versions in inst into github. Why? One of the displayr project requirements is that all R packages, including HTML Widgets, must be installable via a single `devtools::install_github` command. This means that all of outputs of the build process must be checked in to git.

_**So lets recap a really important point: only edit files in the `theSrc`, and `docs` directories.**_. All files in the `R/`, `inst/`, and `man/` directories are autogenerated by the `gulp build` / `gulp serve` task using input from the `theSrc` directory. If you edit in `inst` and then run `gulp build` it will wipe out all your hard work, and your colleagues will laugh at your misfortune !

## Other Files and Their Roles

There are lots of files. This is what they do:

**Build files**
* **package.json** - this lists all of the npm dependencies. When the project is initially checked out from git, the first thing a developer does is run `npm install`. The `npm install` command reads the `package.json` file and locally installs all of the specified dependencies into the `node_modules` directory.
* **gulpfile.js** - this defines and implements the build tasks. Any task can be defined and arbitrarily named. In htmlwidget projects the two main tasks are `serve` and `build`.
* **build/makeDoc.r** - utility to generate the R docs via roxygen
* **build/generateExamplesInR.js** - utility to translate `features.json` into `examples/features.R`

**Auto Generated files**
* **browser/** - this content is **autogenerated** and is used to test and develop the htmlwidget in a chrome browser context - this is done when running gulp serve.
* **inst/** - this is **autogenerated** and is a required directory where the HTML widget framework will look for all its JS resources
* **man** - this is **autogenerated** and contains R docs
* **R** - this is **autogenerated** and contains the R function signature for the html widget
* **examples/features.R - this is **autogenerated** and contains R code examples showinbg intended use of the htmlwidget

**Feature files**
* **theSrc/features/features.json** - contains examples used in the browser and used to generate the R examples file. Basically the examples demonstrate the intended use of the widget

**Src Files**
* **theSrc/scripts/** - This is your coffeescript source. This is what you change. There are more notes on the source code in the [how the code works](./how_the_code_works.md) docs
* **theSrc/images** - put your images here, you can use them in the browser but at present we dont know how to package images in htmlwidgets !
* **theSrc/index.html** - dev file only. This is the first page you see in the browser when you run `gulp serve`. It loads `features.json` and generates a list of examples.
* **theSrc/render.html** - dev file only. This file is a bit magic. It mocks out the htmlwidget framework, intercepts your widget definition, then renders your widget in the browser. _**You may need to make small changes to this file. Tread lightly**_ There are instructions in the file for what is likely to need changing.
* **theSrc/scenarios.r.html** - dev file only. This file reads `features.json` and generates R commands. The user can copy/paste these in to try the widget out in R.
* **theSrc/R/htmlwidget.R** - this is copied to R/WIDGETNAME.R and contains the R function definitions used to invoke your widget. _**You do not need to rename this file.**_
* **theSrc/R/htmlwidget.yaml** - this is copied to inst/htmlwidget/WIDGETNAME.yaml and contains a manifest the htmlwidget framework uses. See [http://www.htmlwidgets.orghttp://www.htmlwidgets.org/develop_intro.html](http://www.htmlwidgets.org/develop_intro.html) for details. _**You do not need to rename this file.**_. You will have to update it to match the js files and dependencies you add.
* **theSrc/styles/main.less** - this is your CSS in a less file. It is used to generate `inst/htmlwidgets/lib/style/main.css`

## Terminology/Technology Breakdown

What does the above really mean ?

**Node project** : Fundamentally all this means is two things:

1. the project contains nodejs code (which is just javascript run on the "server" not in the "browser")
1. there is a package.json file at the project root, and that package.json file defines all of the nodejs and browser javascript that is required for the project.

Once a git repo has a package.json, then anyone who clones the repo onto their local machine can download all of the project dependencies simply by running `npm install`. This of course assumes that node and npm are already installed.

**Coffeescript**: Ever written a lot of code in ES5 Javascript? It sucks! The newest versions of Javascript - ES6 aka ES2016 - is significantly better, however is was only recently stanrdardized and is not yet universally supported by modern browsers. Coffeescript provides a lot of syntactic sugar and missing language features that makes JS code looks much cleaner and it easier to read, write, and maintina. In this project all 'production' (i.e., code that is included in the R package) javascript code is written as coffeescript and is 'transpiled' into Javascript. There are alternatives that achieve the same aim: A) write in ES6 and transpile into ES5. B) Write in typescript and transpile into ES5. C) Just write ES5 and be sad.

**Transpile ??** : Compiling is generally understood to be converting a higher level of abstraction into a lower one, for example taking C++ and producing X86 assembly code. Transpiling is converting to/from languages of equal levels of abstraction, for example coffeescript to ES5 javascript, or ES6 javascript to ES5 javascript. This is necessary because modern web browsers still do not have consistent 100% support for ES6 (aka ES2015) javascript. At present, if you want your javascript to work in a good percentage of your customers' browsers, then you need to produce ES5. The problem is that ES5 is missing a LOT of modern language features and makes developers sad.

**HTML Widget Packages**: A R HTML Widget is a special type of R package that contains R code, as well as Javascript. In the case of most HTML Widgets (warning arbitrary stat) 95%  of the code is Javascript and there is very little R code. The majority of our 3rd party dependencies are Javascript packages, so it makes sense to adopt a dependency management system and best practices from the nodejs community (i.e., npm packaging and gulp build tool). However, the end product is still R code. We need a way to use npm to dynamically pull all our dependencies, but still produce a compliant R HTMLWidget package, enter the ....

**Gulp Build System**: Gulp is one of several nodejs based task managers that provide standard ways to define multi step development tasks such as code packaging, code testing, code compiling, and many other common tasks. It's kind of like `make` . Alternatives exist such as grunt and webpack; we are using gulp. Gulp is easiest understood by providing examples, which are provided in the next section.

## Why `theSrc` instead of `src`

I think that R treats all the code in `src` as C/C++ code and compiles it when you run a `devtools::install()`. This only happens on Windows. In any case, best not call your src folder `src` unless you want trouble.

## I'm totally sold! How do I make my htmlwidget use this system ?

Excellent, it would be great if we had a yeoman style project template, but in the absense of that, follow the instructions in [exending the template](./extending_the_template.md).
