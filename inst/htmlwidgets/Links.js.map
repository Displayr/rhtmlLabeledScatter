{"version":3,"file":"Links.es6.js","names":[],"mappings":"","sources":["Links.es6.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Links = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Links = function () {\n  Links.prototype._labIsInsideBubblePt = function _labIsInsideBubblePt(lab, pt) {\n    var labLeftBorder = lab.x - lab.width / 2;\n    var labRightBorder = lab.x + lab.width / 2;\n    var labBotBorder = lab.y;\n    var labTopBorder = lab.y - lab.height;\n\n    return labRightBorder < pt.x + pt.r && labLeftBorder > pt.x - pt.r && labBotBorder < pt.y + pt.r && labTopBorder > pt.y - pt.r;\n  };\n\n  function Links(pts, lab) {\n    _classCallCheck(this, Links);\n\n    this.getLinkData = this.getLinkData.bind(this);\n    this.getNewPtOnLogoLabelBorder = this.getNewPtOnLogoLabelBorder.bind(this);\n    this.getNewPtOnTxtLabelBorder = this.getNewPtOnTxtLabelBorder.bind(this);\n    this.getPtOnAncBorder = this.getPtOnAncBorder.bind(this);\n\n    var _labIsText = function _labIsText(labelData) {\n      return labelData.url === '';\n    };\n\n    this.links = [];\n    for (var i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var newLinkPt = null;\n      if (!this._labIsInsideBubblePt(lab[i], pt)) {\n        if (_labIsText(lab[i])) {\n          newLinkPt = this.getNewPtOnTxtLabelBorder(lab[i], pt, pts);\n        } else {\n          newLinkPt = this.getNewPtOnLogoLabelBorder(lab[i], pt, pts);\n        }\n      }\n\n      if (newLinkPt != null) {\n        var ancBorderPt = this.getPtOnAncBorder(pt.x, pt.y, pt.r, newLinkPt[0], newLinkPt[1]);\n        this.links.push({\n          x1: ancBorderPt[0],\n          y1: ancBorderPt[1],\n          x2: newLinkPt[0],\n          y2: newLinkPt[1],\n          width: 1,\n          color: pt.color\n        });\n      }\n    }\n  }\n\n  Links.prototype.getLinkData = function getLinkData() {\n    return this.links;\n  };\n\n  Links.prototype.getNewPtOnLogoLabelBorder = function getNewPtOnLogoLabelBorder(label, anchor) {\n    // Don't draw a link if anc is inside logo\n    var region = void 0;\n    if (label.x - label.width / 2 < anchor.x && anchor.x < label.x + label.width / 2 && label.y - label.height < anchor.y && anchor.y < label.y) {\n      return null;\n    }\n\n    // Calculations reference - http://stackoverflow.com/questions/4061576/finding-points-on-a-rectangle-at-a-given-angle\n    var a = label.width;\n    var b = label.height;\n    var labx = label.x;\n    var laby = label.y - label.height / 2;\n\n    var dx = anchor.x - labx;\n    var dy = anchor.y - laby;\n    var angle = Math.atan(dy / dx);\n\n    if (-Math.atan(b / a) < angle && angle < Math.atan(b / a)) {\n      region = 1;\n    } else if (Math.atan(b / a) < angle && angle < Math.PI - Math.atan(b / a)) {\n      region = 2;\n    } else if (Math.PI - Math.atan(b / a) < angle && angle < Math.PI + Math.atan(b / a)) {\n      region = 3;\n    } else if (Math.PI + Math.atan(b / a) < angle || angle < -Math.atan(b / a)) {\n      region = 4;\n    }\n\n    if (region === 1 || region === 3) {\n      if (dx > 0) {\n        return [labx + a / 2, a / 2 * Math.tan(angle) + laby];\n      } else {\n        return [labx - a / 2, -(a / 2 * Math.tan(angle)) + laby];\n      }\n    } else if (region === 2 || region === 4) {\n      if (dy > 0) {\n        return [labx + b / (2 * Math.tan(angle)), b / 2 + laby];\n      } else {\n        return [labx - b / (2 * Math.tan(angle)), -b / 2 + laby];\n      }\n    }\n\n    return null;\n  };\n\n  // calc the links from anc to label text if ambiguous\n\n\n  Links.prototype.getNewPtOnTxtLabelBorder = function getNewPtOnTxtLabelBorder(label, anchor, anchorArray) {\n    var labelXmid = label.x;\n    var labelXleft = label.x - label.width / 2;\n    var labelXright = label.x + label.width / 2;\n\n    var labelYbot = label.y;\n    var labelYtop = label.y - label.height;\n    var labelYmid = label.y - label.height / 2;\n\n    var ancL = anchor.x - anchor.r;\n    var ancR = anchor.x + anchor.r;\n    var ancT = anchor.y + anchor.r;\n    var ancB = anchor.y - anchor.r;\n\n    var labelBorder = {\n      botL: [labelXleft, labelYbot],\n      botC: [labelXmid, labelYbot],\n      botR: [labelXright, labelYbot],\n      topL: [labelXleft, labelYtop + 7],\n      topC: [labelXmid, labelYtop + 7],\n      topR: [labelXright, labelYtop + 7],\n      midL: [labelXleft, labelYmid],\n      midR: [labelXright, labelYmid]\n    };\n\n    var padding = 10;\n    var centered = ancR > labelXleft && ancL < labelXright;\n    var abovePadded = ancB < labelYtop - padding;\n    var above = ancB < labelYtop;\n    var belowPadded = ancT > labelYbot + padding;\n    var below = ancT > labelYbot;\n    var left = ancR < labelXleft;\n    var right = ancL > labelXright;\n    var leftPadded = ancR < labelXleft - padding;\n    var rightPadded = ancL > labelXright + padding;\n\n    if (centered && abovePadded) {\n      return labelBorder.topC;\n    } else if (centered && belowPadded) {\n      return labelBorder.botC;\n    } else if (above && left) {\n      return labelBorder.topL;\n    } else if (above && right) {\n      return labelBorder.topR;\n    } else if (below && left) {\n      return labelBorder.botL;\n    } else if (below && right) {\n      return labelBorder.botR;\n    } else if (leftPadded) {\n      return labelBorder.midL;\n    } else if (rightPadded) {\n      return labelBorder.midR;\n    } else {\n      // Draw the link if there are any anc nearby\n      var ambiguityFactor = 10;\n      var padL = labelBorder.topL[0] - ambiguityFactor;\n      var padR = labelBorder.topR[0] + ambiguityFactor;\n      var padT = labelBorder.topL[1] - ambiguityFactor;\n      var padB = labelBorder.botR[1] + ambiguityFactor;\n      var ancNearby = 0;\n      _(anchorArray).each(function (a) {\n        if (a.x > padL && a.x < padR && a.y > padT && a.y < padB) {\n          ancNearby++;\n        }\n      });\n      if (ancNearby > 1) {\n        if (!left && !right && !above && !below) {\n          return labelBorder.botC;\n        } else if (centered && above) {\n          return labelBorder.topC;\n        } else if (centered && below) {\n          return labelBorder.botC;\n        } else if (left && above) {\n          return labelBorder.topL;\n        } else if (left && below) {\n          return labelBorder.botL;\n        } else if (right && above) {\n          return labelBorder.topR;\n        } else if (right && below) {\n          return labelBorder.botR;\n        } else if (left) {\n          return labelBorder.midL;\n        } else if (right) {\n          return labelBorder.midR;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  Links.prototype.getPtOnAncBorder = function getPtOnAncBorder(cx, cy, cr, x, y) {\n    var opp = Math.abs(cy - y);\n    var adj = Math.abs(cx - x);\n    var angle = Math.atan(opp / adj);\n\n    var dx = cr * Math.cos(angle);\n    var dy = cr * Math.sin(angle);\n\n    var finalX = x < cx ? cx - dx : cx + dx;\n    var finalY = y < cy ? cy - dy : cy + dy;\n\n    return [finalX, finalY];\n  };\n\n  return Links;\n}();\n\nmodule.exports = Links;\n\n},{}]},{},[1])(1)\n});\n\n"],"sourceRoot":"/source/"}