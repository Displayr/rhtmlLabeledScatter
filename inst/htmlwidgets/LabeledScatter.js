// Generated by CoffeeScript 1.8.0
var LabeledScatter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

LabeledScatter = (function(_super) {
  var calcViewBoxDim;

  __extends(LabeledScatter, _super);

  function LabeledScatter(el, width, height) {
    LabeledScatter.__super__.constructor.call(this, el, width, height);
    this.width = width;
    this.height = height;
    this._initializeState({
      selected: null
    });
  }

  LabeledScatter.prototype.resize = function(width, height) {
    this.width = width;
    this.height = height;
    return _redraw();
  };

  LabeledScatter.prototype._processConfig = function() {
    console.log('_processConfig. Change this function in your rhtmlWidget');
    console.log('the config has already been added to the context at @config, you must now "process" it');
    return console.log(this.config);
  };

  LabeledScatter.prototype._redraw = function() {
    var anc, axisLabels, between, colsNegative, colsPositive, data, dimensionMarkerLabelStack, dimensionMarkerLeaderStack, dimensionMarkerStack, i, lab, labeler, labels_svg, maxX, maxY, minX, minY, normalizeXCoords, normalizeYCoords, originAxis, originX, originY, pts, pushDimensionMarker, rowsNegative, rowsPositive, threshold, val, viewBoxDim, x1, x2, xAxisPadding, y1, y2, yAxisPadding;
    console.log('_redraw. Change this function in your rhtmlWidget');
    console.log('the outer SVG has already been created and added to the DOM. You should do things with it');
    data = testData;
    viewBoxDim = calcViewBoxDim(testData.X, testData.Y, this.width, this.height);
    viewBoxDim['x'] = this.width / 5;
    viewBoxDim['y'] = this.height / 5;
    this.outerSvg.append('rect').attr('class', 'plot-viewbox').attr('x', viewBoxDim.x).attr('y', viewBoxDim.y).attr('width', viewBoxDim.width).attr('height', viewBoxDim.height).attr('fill', 'none').attr('stroke', 'black').attr('stroke-width', '1px');
    minX = Infinity;
    maxX = -Infinity;
    minY = Infinity;
    maxY = -Infinity;
    i = 0;
    while (i < data.X.length) {
      if (minX > data.X[i]) {
        minX = data.X[i];
      }
      if (maxX < data.X[i]) {
        maxX = data.X[i];
      }
      if (minY > data.Y[i]) {
        minY = data.Y[i];
      }
      if (maxY < data.Y[i]) {
        maxY = data.Y[i];
      }
      i++;
    }
    threshold = 0.05;
    i = 0;
    while (i < data.X.length) {
      data.X[i] = threshold + (data.X[i] - minX) / (maxX - minX) * (1 - 2 * threshold);
      data.Y[i] = threshold + (data.Y[i] - minY) / (maxY - minY) * (1 - 2 * threshold);
      i++;
    }
    normalizeXCoords = function(Xcoord) {
      return (Xcoord - minX) / (maxX - minX) * viewBoxDim.width + viewBoxDim.x;
    };
    normalizeYCoords = function(Ycoord) {
      return (Ycoord - minY) / (maxY - minY) * viewBoxDim.height + viewBoxDim.y;
    };
    between = function(num, min, max) {
      return num > min && num < max;
    };
    colsPositive = 0;
    colsNegative = 0;
    i = 0.25;
    while (between(i, minX, maxX) || between(-i, minX, maxX)) {
      if (between(i, minX, maxX)) {
        colsPositive++;
      }
      if (between(-i, minX, maxX)) {
        colsNegative++;
      }
      i += 0.25;
    }
    rowsPositive = 0;
    rowsNegative = 0;
    i = 0.25;
    while (between(i, minY, maxY) || between(-i, minY, maxY)) {
      if (between(i, minY, maxY)) {
        rowsNegative++;
      }
      if (between(-i, minY, maxY)) {
        rowsPositive++;
      }
      i += 0.25;
    }
    pts = [];
    lab = [];
    anc = [];
    i = 0;
    while (i < data.X.length) {
      pts.push({
        x: data.X[i] * viewBoxDim.width + viewBoxDim.x,
        y: data.Y[i] * viewBoxDim.height + viewBoxDim.y,
        r: 2,
        label: data.label[i],
        labelX: data.X[i] * viewBoxDim.width + viewBoxDim.x,
        labelY: data.Y[i] * viewBoxDim.height + viewBoxDim.y,
        group: data.group[i]
      });
      lab.push({
        x: data.X[i] * viewBoxDim.width + viewBoxDim.x,
        y: data.Y[i] * viewBoxDim.height + viewBoxDim.y,
        text: data.label[i]
      });
      anc.push({
        x: data.X[i] * viewBoxDim.width + viewBoxDim.x,
        y: data.Y[i] * viewBoxDim.height + viewBoxDim.y,
        r: 2
      });
      i++;
    }
    this.outerSvg.selectAll('.anc').data(pts).enter().append('circle').attr('class', 'anc').attr('cx', function(d) {
      return d.x;
    }).attr('cy', function(d) {
      return d.y;
    }).attr('r', function(d) {
      return d.r;
    });
    labels_svg = this.outerSvg.selectAll('.label').data(lab).enter().append('text').attr('class', 'init-labs').attr('x', function(d) {
      return d.x;
    }).attr('y', function(d) {
      return d.y;
    }).attr('font-family', 'Arial Narrow').text(function(d) {
      return d.text;
    }).attr('text-anchor', 'middle');
    i = 0;
    while (i < data.X.length) {
      lab[i].width = labels_svg[0][i].getBBox().width;
      lab[i].height = labels_svg[0][i].getBBox().height;
      i++;
    }
    labeler = d3.labeler().svg(this.outerSvg).w1(viewBoxDim.x).w2(viewBoxDim.x + viewBoxDim.width).h1(viewBoxDim.y).h2(viewBoxDim.y + viewBoxDim.height).anchor(anc).label(lab).start(500);
    labels_svg.transition().duration(800).attr('x', function(d) {
      return d.x;
    }).attr('y', function(d) {
      return d.y;
    });
    originX = normalizeXCoords(0);
    originY = normalizeYCoords(0);
    originAxis = [
      {
        x1: viewBoxDim.x,
        y1: originY,
        x2: viewBoxDim.x + viewBoxDim.width,
        y2: originY
      }, {
        x1: originX,
        y1: viewBoxDim.y,
        x2: originX,
        y2: viewBoxDim.y + viewBoxDim.height
      }
    ];
    this.outerSvg.selectAll('.origin').data(originAxis).enter().append('line').attr('class', 'origin').attr('x1', function(d) {
      return d.x1;
    }).attr('y1', function(d) {
      return d.y1;
    }).attr('x2', function(d) {
      return d.x2;
    }).attr('y2', function(d) {
      return d.y2;
    }).attr('stroke-width', 1).attr('stroke', 'black').style("stroke-dasharray", "3, 3");
    dimensionMarkerStack = [];
    dimensionMarkerLeaderStack = [];
    dimensionMarkerLabelStack = [];
    pushDimensionMarker = function(type, x1, y1, x2, y2, label) {
      var labelHeight, leaderLineLen, numShown;
      leaderLineLen = 5;
      labelHeight = 15;
      numShown = label.toFixed(1);
      if (type === 'c') {
        dimensionMarkerLeaderStack.push({
          x1: x1,
          y1: y2,
          x2: x1,
          y2: y2 + leaderLineLen
        });
        dimensionMarkerLabelStack.push({
          x: x1,
          y: y2 + leaderLineLen + labelHeight,
          label: numShown,
          anchor: 'middle'
        });
      }
      if (type === 'r') {
        dimensionMarkerLeaderStack.push({
          x1: x1 - leaderLineLen,
          y1: y1,
          x2: x1,
          y2: y2
        });
        return dimensionMarkerLabelStack.push({
          x: x1 - leaderLineLen,
          y: y2 + labelHeight / 3,
          label: numShown,
          anchor: 'end'
        });
      }
    };
    pushDimensionMarker('r', originAxis[0].x1, originAxis[0].y1, originAxis[0].x2, originAxis[0].y2, 0);
    pushDimensionMarker('c', originAxis[1].x1, originAxis[1].y1, originAxis[1].x2, originAxis[1].y2, 0);
    i = 0;
    while (i < Math.max(colsPositive, colsNegative)) {
      if (i < colsPositive) {
        val = (i + 1) * 0.25;
        x1 = normalizeXCoords(val);
        y1 = viewBoxDim.y;
        x2 = normalizeXCoords(val);
        y2 = viewBoxDim.y + viewBoxDim.height;
        dimensionMarkerStack.push({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        });
        if (i % 2) {
          pushDimensionMarker('c', x1, y1, x2, y2, val);
        }
      }
      if (i < colsNegative) {
        val = -(i + 1) * 0.25;
        x1 = normalizeXCoords(val);
        y1 = viewBoxDim.y;
        x2 = normalizeXCoords(val);
        y2 = viewBoxDim.y + viewBoxDim.height;
        dimensionMarkerStack.push({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        });
        if (i % 2) {
          pushDimensionMarker('c', x1, y1, x2, y2, val);
        }
      }
      i++;
    }
    i = 0;
    while (i < Math.max(rowsPositive, rowsNegative)) {
      x1 = y1 = x2 = y2 = 0;
      if (i < rowsPositive) {
        val = -(i + 1) * 0.25;
        x1 = viewBoxDim.x;
        y1 = normalizeYCoords(val);
        x2 = viewBoxDim.x + viewBoxDim.width;
        y2 = normalizeYCoords(val);
        dimensionMarkerStack.push({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        });
        if (i % 2) {
          pushDimensionMarker('r', x1, y1, x2, y2, val);
        }
      }
      if (i < rowsNegative) {
        val = (i + 1) * 0.25;
        x1 = viewBoxDim.x;
        y1 = normalizeYCoords(val);
        x2 = viewBoxDim.x + viewBoxDim.width;
        y2 = normalizeYCoords(val);
        dimensionMarkerStack.push({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        });
        if (i % 2) {
          pushDimensionMarker('r', x1, y1, x2, y2, val);
        }
      }
      i++;
    }
    yAxisPadding = 30;
    xAxisPadding = 40;
    axisLabels = [
      {
        x: viewBoxDim.x + viewBoxDim.width / 2,
        y: viewBoxDim.y + viewBoxDim.height + xAxisPadding,
        text: 'Dimension 1 (64%)',
        anchor: 'middle',
        transform: 'rotate(0)'
      }, {
        x: viewBoxDim.x - yAxisPadding,
        y: viewBoxDim.y + viewBoxDim.height / 2,
        text: 'Dimension 2 (24%)',
        anchor: 'middle',
        transform: 'rotate(270,' + (viewBoxDim.x - yAxisPadding) + ', ' + (viewBoxDim.y + viewBoxDim.height / 2) + ')'
      }
    ];
    this.outerSvg.selectAll('.dim-marker').data(dimensionMarkerStack).enter().append('line').attr('class', 'dim-marker').attr('x1', function(d) {
      return d.x1;
    }).attr('y1', function(d) {
      return d.y1;
    }).attr('x2', function(d) {
      return d.x2;
    }).attr('y2', function(d) {
      return d.y2;
    }).attr('stroke-width', 0.2).attr('stroke', 'grey');
    this.outerSvg.selectAll('.dim-marker-leader').data(dimensionMarkerLeaderStack).enter().append('line').attr('class', 'dim-marker-leader').attr('x1', function(d) {
      return d.x1;
    }).attr('y1', function(d) {
      return d.y1;
    }).attr('x2', function(d) {
      return d.x2;
    }).attr('y2', function(d) {
      return d.y2;
    }).attr('stroke-width', 1).attr('stroke', 'black');
    this.outerSvg.selectAll('.dim-marker-label').data(dimensionMarkerLabelStack).enter().append('text').attr('x', function(d) {
      return d.x;
    }).attr('y', function(d) {
      return d.y;
    }).attr('font-family', 'Arial Narrow').text(function(d) {
      return d.label;
    }).attr('text-anchor', function(d) {
      return d.anchor;
    });
    return this.outerSvg.selectAll('.axis-label').data(axisLabels).enter().append('text').attr('x', function(d) {
      return d.x;
    }).attr('y', function(d) {
      return d.y;
    }).attr('font-family', 'Arial').attr('text-anchor', function(d) {
      return d.anchor;
    }).attr('transform', function(d) {
      return d.transform;
    }).text(function(d) {
      return d.text;
    }).style('font-weight', 'bold');
  };

  calcViewBoxDim = function(X, Y, width, height) {
    return {
      width: width / 2,
      height: height / 2,
      rangeX: Math.max.apply(null, X) - Math.min.apply(null, X),
      rangeY: Math.max.apply(null, Y) - Math.min.apply(null, Y)
    };
  };

  return LabeledScatter;

})(RhtmlSvgWidget);
