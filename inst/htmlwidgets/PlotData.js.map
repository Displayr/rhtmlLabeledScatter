{"version":3,"file":"PlotData.es6.js","names":[],"mappings":"","sources":["PlotData.es6.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PlotData = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// To Refactor:\n//   * fixed aspect ratio code can (probably) be simplified : see Pictograph utils/geometryUtils.js\n//\n\n\nvar PlotData = function () {\n  function PlotData(X, Y, Z, group, label, labelAlt, viewBoxDim, legendDim, colorWheel, fixedAspectRatio, originAlign, pointRadius, bounds, transparency, legendShow, legendBubblesShow, axisDimensionText) {\n    _classCallCheck(this, PlotData);\n\n    this.revertMinMax = this.revertMinMax.bind(this);\n    this.calculateMinMax = this.calculateMinMax.bind(this);\n    this.normalizeData = this.normalizeData.bind(this);\n    this.normalizeZData = this.normalizeZData.bind(this);\n    this.getPtsAndLabs = this.getPtsAndLabs.bind(this);\n    this.setLegendItemsPositions = this.setLegendItemsPositions.bind(this);\n    this.setupLegendGroupsAndPts = this.setupLegendGroupsAndPts.bind(this);\n    this.resizedAfterLegendGroupsDrawn = this.resizedAfterLegendGroupsDrawn.bind(this);\n    this.isOutsideViewBox = this.isOutsideViewBox.bind(this);\n    this.isLegendPtOutsideViewBox = this.isLegendPtOutsideViewBox.bind(this);\n    this.addElemToLegend = this.addElemToLegend.bind(this);\n    this.removeElemFromLegend = this.removeElemFromLegend.bind(this);\n    this.X = X;\n    this.Y = Y;\n    this.Z = Z;\n    this.group = group;\n    this.label = label;\n    this.labelAlt = labelAlt;\n    this.viewBoxDim = viewBoxDim;\n    this.legendDim = legendDim;\n    this.colorWheel = colorWheel;\n    this.fixedAspectRatio = fixedAspectRatio;\n    this.originAlign = originAlign;\n    this.pointRadius = pointRadius;\n    this.bounds = bounds;\n    this.transparency = transparency;\n    this.legendShow = legendShow;\n    this.legendBubblesShow = legendBubblesShow;\n    this.axisDimensionText = axisDimensionText;\n    this.origX = this.X.slice(0);\n    this.origY = this.Y.slice(0);\n    this.normX = this.X.slice(0);\n    this.normY = this.Y.slice(0);\n    if (Utils.isArrOfNums(this.Z) && this.Z.length === this.X.length) {\n      this.normZ = this.Z.slice();\n    }\n    this.outsidePlotPtsId = [];\n    this.legendPts = [];\n    this.outsidePlotCondensedPts = [];\n    this.legendBubbles = [];\n    this.legendBubblesLab = [];\n    this.legendRequiresRedraw = false;\n\n    if (this.X.length === this.Y.length) {\n      this.len = this.origLen = X.length;\n      this.normalizeData();\n      if (Utils.isArrOfNums(this.Z)) {\n        this.normalizeZData();\n      }\n      this.plotColors = new PlotColors(this);\n      this.labelNew = new PlotLabel(this.label, this.labelAlt, this.viewBoxDim.labelLogoScale);\n    } else {\n      throw new Error('Inputs X and Y lengths do not match!');\n    }\n  }\n\n  PlotData.prototype.revertMinMax = function revertMinMax() {\n    this.minX = this.minXold;\n    this.maxX = this.maxXold;\n    this.minY = this.minYold;\n    return this.maxY = this.maxYold;\n  };\n\n  PlotData.prototype.calculateMinMax = function calculateMinMax() {\n    this.minXold = this.minX;\n    this.maxXold = this.maxX;\n    this.minYold = this.minY;\n    this.maxYold = this.maxY;\n\n    var ptsOut = this.outsidePlotPtsId;\n    var notMovedX = _.filter(this.origX, function (val, key) {\n      return !(_.indexOf(ptsOut, key) !== -1);\n    });\n    var notMovedY = _.filter(this.origY, function (val, key) {\n      return !(_.indexOf(ptsOut, key) !== -1);\n    });\n\n    this.minX = _.min(notMovedX);\n    this.maxX = _.max(notMovedX);\n    this.minY = _.min(notMovedY);\n    this.maxY = _.max(notMovedY);\n\n    // threshold used so pts are not right on border of plot\n    var rangeX = this.maxX - this.minX;\n    var rangeY = this.maxY - this.minY;\n    var thres = 0.08;\n    var xThres = thres * rangeX;\n    var yThres = thres * rangeY;\n    if (xThres === 0) {\n      // if there is no difference, add arbitrary threshold of 1\n      xThres = 1;\n    }\n    if (yThres === 0) {\n      // if there is no difference, add arbitrary threshold of 1\n      yThres = 1;\n    }\n\n    // Note: Thresholding increase the space around the points which is why we add to the max and min\n    this.maxX += xThres;\n    this.minX -= xThres;\n    this.maxY += yThres;\n    this.minY -= yThres;\n\n    // originAlign: compensates to make sure origin lines are on axis\n    if (this.originAlign) {\n      this.maxX = this.maxX < 0 ? 0 : this.maxX + xThres; // so axis can be on origin\n      this.minX = this.minX > 0 ? 0 : this.minX - xThres;\n      this.maxY = this.maxY < 0 ? 0 : this.maxY + yThres;\n      this.minY = this.minY > 0 ? 0 : this.minY - yThres;\n    }\n\n    // TODO KZ (another) this can be simplified : see Pictograph utils/geometryUtils.js\n    if (this.fixedAspectRatio) {\n      rangeX = this.maxX - this.minX;\n      rangeY = this.maxY - this.minY;\n      var rangeAR = Math.abs(rangeX / rangeY);\n      var widgetAR = this.viewBoxDim.width / this.viewBoxDim.height;\n      var rangeToWidgetARRatio = widgetAR / rangeAR;\n\n      if (widgetAR >= 1) {\n        if (rangeX > rangeY) {\n          if (rangeToWidgetARRatio > 1) {\n            this.maxX += (widgetAR * rangeY - rangeX) / 2;\n            this.minX -= (widgetAR * rangeY - rangeX) / 2;\n          } else {\n            this.maxY += (1 / widgetAR * rangeX - rangeY) / 2;\n            this.minY -= (1 / widgetAR * rangeX - rangeY) / 2;\n          }\n        } else if (rangeX < rangeY) {\n          this.maxX += (widgetAR * rangeY - rangeX) / 2;\n          this.minX -= (widgetAR * rangeY - rangeX) / 2;\n        }\n      } else if (rangeX < rangeY) {\n        if (rangeToWidgetARRatio < 1) {\n          this.maxY += (1 / widgetAR * rangeX - rangeY) / 2;\n          this.minY -= (1 / widgetAR * rangeX - rangeY) / 2;\n        } else {\n          this.maxX += (widgetAR * rangeY - rangeX) / 2;\n          this.minX -= (widgetAR * rangeY - rangeX) / 2;\n        }\n      } else if (rangeX > rangeY) {\n        this.maxY += (1 / widgetAR * rangeX - rangeY) / 2;\n        this.minY -= (1 / widgetAR * rangeX - rangeY) / 2;\n      }\n    }\n\n    // TODO KZ this should be done first to skip the wasted computation (unless there are side effect in the above) ??\n    // If user has sent x and y boundaries, these hold higher priority\n    if (Utils.isNum(this.bounds.xmax)) {\n      this.maxX = this.bounds.xmax;\n    }\n    if (Utils.isNum(this.bounds.xmin)) {\n      this.minX = this.bounds.xmin;\n    }\n    if (Utils.isNum(this.bounds.ymax)) {\n      this.maxY = this.bounds.ymax;\n    }\n    if (Utils.isNum(this.bounds.ymin)) {\n      return this.minY = this.bounds.ymin;\n    }\n  };\n\n  PlotData.prototype.normalizeData = function normalizeData() {\n    var _this = this;\n\n    // TODO KZ remove this side effect. Plus Data.calcMinMax is called over and over in the code. Why ??\n    var i = void 0;\n    this.calculateMinMax();\n\n    // create list of movedOffPts that need markers\n    this.outsidePlotMarkers = [];\n    this.outsidePlotMarkersIter = 0;\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Array.from(this.legendPts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var lp = _step.value;\n        var id = lp.pt.id;\n\n        var draggedNormX = (this.X[id] - this.minX) / (this.maxX - this.minX);\n        var draggedNormY = (this.Y[id] - this.minY) / (this.maxY - this.minY);\n        // TODO KZ the ++ should be immed. after the use of the iter !\n        var newMarkerId = this.outsidePlotMarkersIter;\n        lp.markerId = newMarkerId;\n\n        if (Math.abs(draggedNormX) > 1 || Math.abs(draggedNormY) > 1 || draggedNormX < 0 || draggedNormY < 0) {\n          var markerTextY, x1, y1;\n          draggedNormX = draggedNormX > 1 ? 1 : draggedNormX;\n          draggedNormX = draggedNormX < 0 ? 0 : draggedNormX;\n          draggedNormY = draggedNormY > 1 ? 1 : draggedNormY;\n          draggedNormY = draggedNormY < 0 ? 0 : draggedNormY;\n          var x2 = draggedNormX * this.viewBoxDim.width + this.viewBoxDim.x;\n          var y2 = (1 - draggedNormY) * this.viewBoxDim.height + this.viewBoxDim.y;\n\n          var markerTextX = markerTextY = 0;\n          var numDigitsInId = Math.ceil(Math.log(newMarkerId + 1.1) / Math.LN10);\n          if (draggedNormX === 1) {\n            // right bound\n            x1 = x2 + this.legendDim.markerLen;\n            y1 = y2;\n            markerTextX = x1;\n            markerTextY = y1 + this.legendDim.markerTextSize / 2;\n          } else if (draggedNormX === 0) {\n            // left bound\n            x1 = x2 - this.legendDim.markerLen;\n            y1 = y2;\n            markerTextX = x1 - this.legendDim.markerCharWidth * (numDigitsInId + 1);\n            markerTextY = y1 + this.legendDim.markerTextSize / 2;\n          } else if (draggedNormY === 1) {\n            // top bound\n            x1 = x2;\n            y1 = y2 + -draggedNormY * this.legendDim.markerLen;\n            markerTextX = x1 - this.legendDim.markerCharWidth * numDigitsInId;\n            markerTextY = y1;\n          } else if (draggedNormY === 0) {\n            // bot bound\n            x1 = x2;\n            y1 = y2 + this.legendDim.markerLen;\n            markerTextX = x1 - this.legendDim.markerCharWidth * numDigitsInId;\n            markerTextY = y1 + this.legendDim.markerTextSize;\n          }\n\n          // TODO KZ bug? : newMarkerId + 1, but lp.markerId = newMarker ??\n          this.outsidePlotMarkers.push({\n            markerLabel: newMarkerId + 1,\n            ptId: id,\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            markerTextX: markerTextX,\n            markerTextY: markerTextY,\n            width: this.legendDim.markerWidth,\n            color: lp.color\n          });\n\n          // if the points were condensed, remove point\n          this.outsidePlotCondensedPts = _.filter(this.outsidePlotCondensedPts, function (e) {\n            return e.dataId !== id;\n          });\n          this.len = this.origLen - this.outsidePlotMarkers.length;\n        } else {\n          // no marker required, but still inside plot window\n          console.log('rhtmlLabeledScatter: Condensed point added');\n          var condensedPtsDataIdArray = _.map(this.outsidePlotCondensedPts, function (e) {\n            return e.dataId;\n          });\n          if (!(_.indexOf(condensedPtsDataIdArray, id) !== -1)) {\n            this.outsidePlotCondensedPts.push({\n              dataId: id,\n              markerId: newMarkerId\n            });\n          }\n        }\n        this.outsidePlotMarkersIter++;\n      }\n\n      // Remove pts that are outside plot if user bounds were set\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    this.outsideBoundsPtsId = [];\n    if (_.some(this.bounds, function (b) {\n      return Utils.isNum(b);\n    })) {\n      i = 0;\n      while (i < this.origLen) {\n        if (!(_.indexOf(this.outsideBoundsPtsId, i) !== -1)) {\n          if (this.X[i] < this.minX || this.X[i] > this.maxX || this.Y[i] < this.minY || this.Y[i] > this.maxY) {\n            this.outsideBoundsPtsId.push(i);\n          }\n        }\n        i++;\n      }\n    }\n\n    i = 0;\n    return function () {\n      var result = [];\n      while (i < _this.origLen) {\n        _this.normX[i] = _this.minX === _this.maxX ? _this.minX : (_this.X[i] - _this.minX) / (_this.maxX - _this.minX);\n        // copy/paste bug using x when calculating Y. WTF is this even doing ?\n        _this.normY[i] = _this.minY === _this.maxY ? _this.minX : (_this.Y[i] - _this.minY) / (_this.maxY - _this.minY);\n        result.push(i++);\n      }\n      return result;\n    }();\n  };\n\n  PlotData.prototype.normalizeZData = function normalizeZData() {\n    var legendUtils = LegendUtils;\n\n    var maxZ = _.max(this.Z);\n    legendUtils.calcZQuartiles(this, maxZ);\n    return legendUtils.normalizeZValues(this, maxZ);\n  };\n\n  PlotData.prototype.getPtsAndLabs = function getPtsAndLabs(calleeName) {\n    var _this2 = this;\n\n    console.log('getPtsAndLabs(' + calleeName + ')');\n    return Promise.all(this.labelNew.getLabels()).then(function (resolvedLabels) {\n      //      console.log(\"resolvedLabels for getPtsandLabs callee name #{calleeName}\")\n      //      console.log(resolvedLabels)\n\n      _this2.pts = [];\n      _this2.lab = [];\n\n      var i = 0;\n      while (i < _this2.origLen) {\n        if (!(_.indexOf(_this2.outsidePlotPtsId, i) !== -1) || _.indexOf(_.map(_this2.outsidePlotCondensedPts, function (e) {\n          return e.dataId;\n        }), i) !== -1) {\n          var ptColor;\n          var x = _this2.normX[i] * _this2.viewBoxDim.width + _this2.viewBoxDim.x;\n          var y = (1 - _this2.normY[i]) * _this2.viewBoxDim.height + _this2.viewBoxDim.y;\n          var r = _this2.pointRadius;\n          if (Utils.isArrOfNums(_this2.Z)) {\n            var legendUtils = LegendUtils;\n            r = legendUtils.normalizedZtoRadius(_this2.viewBoxDim, _this2.normZ[i]);\n          }\n          var fillOpacity = _this2.plotColors.getFillOpacity(_this2.transparency);\n\n          var label = resolvedLabels[i].label;\n\n          var labelAlt = (_this2.labelAlt != null ? _this2.labelAlt[i] : undefined) != null ? _this2.labelAlt[i] : '';\n          var width = resolvedLabels[i].width;\n          var height = resolvedLabels[i].height;\n          var url = resolvedLabels[i].url;\n\n\n          var labelZ = Utils.isArrOfNums(_this2.Z) ? _this2.Z[i].toString() : '';\n          var fontSize = _this2.viewBoxDim.labelFontSize;\n\n          // If pt hsa been already condensed\n          if (_.indexOf(_.map(_this2.outsidePlotCondensedPts, function (e) {\n            return e.dataId;\n          }), i) !== -1) {\n            var pt = _.find(_this2.outsidePlotCondensedPts, function (e) {\n              return e.dataId === i;\n            });\n            label = pt.markerId + 1;\n            fontSize = _this2.viewBoxDim.labelSmallFontSize;\n            url = '';\n            width = null;\n            height = null;\n          }\n\n          var fontColor = ptColor = _this2.plotColors.getColor(i);\n          if (_this2.viewBoxDim.labelFontColor != null && !(_this2.viewBoxDim.labelFontColor === '')) {\n            fontColor = _this2.viewBoxDim.labelFontColor;\n          }\n          var group = _this2.group != null ? _this2.group[i] : '';\n          _this2.pts.push({\n            x: x,\n            y: y,\n            r: r,\n            label: label,\n            labelAlt: labelAlt,\n            labelX: _this2.origX[i].toPrecision(3).toString(),\n            labelY: _this2.origY[i].toPrecision(3).toString(),\n            labelZ: labelZ,\n            group: group,\n            color: ptColor,\n            id: i,\n            fillOpacity: fillOpacity\n          });\n          _this2.lab.push({\n            x: x,\n            y: y,\n            color: fontColor,\n            id: i,\n            fontSize: fontSize,\n            fontFamily: _this2.viewBoxDim.labelFontFamily,\n            text: label,\n            width: width,\n            height: height,\n            url: url\n          });\n        }\n        i++;\n      }\n\n      // Remove pts outside plot because user bounds set\n      return function () {\n        var result = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = Array.from(_this2.outsideBoundsPtsId)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var p = _step2.value;\n\n            var item = void 0;\n            if (!(_.indexOf(_this2.outsidePlotPtsId, p) !== -1)) {\n              item = _this2.addElemToLegend(p);\n            }\n            result.push(item);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return result;\n      }();\n    }).catch(function (err) {\n      return console.log(err);\n    });\n  };\n\n  // TODO KZ rename to numColumns once meaning is confirmed\n  // TODO KZ If I have an array, I dont need to be told its length\n\n\n  PlotData.prototype.setLegendItemsPositions = function setLegendItemsPositions(numItems, itemsArray, cols) {\n    var _this3 = this;\n\n    var bubbleLegendTextHeight = 20;\n    this.legendHeight = this.viewBoxDim.height;\n    if (this.legendBubblesTitle != null && this.legendBubblesShow) {\n      this.legendHeight = this.legendBubblesTitle[0].y - bubbleLegendTextHeight - this.viewBoxDim.y;\n    }\n\n    if (this.Zquartiles != null) {\n      var legendUtils = LegendUtils;\n      legendUtils.setupBubbles(this);\n    }\n\n    var startOfCenteredLegendItems = this.viewBoxDim.y + this.legendHeight / 2 - this.legendDim.heightOfRow * (numItems / cols) / 2 + this.legendDim.ptRadius;\n    var startOfViewBox = this.viewBoxDim.y + this.legendDim.ptRadius;\n    var legendStartY = Math.max(startOfCenteredLegendItems, startOfViewBox);\n\n    var colSpacing = 0;\n    var numItemsInPrevCols = 0;\n\n    var i = 0;\n    var currentCol = 1;\n    return function () {\n      var result = [];\n      while (i < numItems) {\n        if (cols > 1) {\n          var numElemsInCol = numItems / cols;\n          var exceededCurrentCol = legendStartY + (i - numItemsInPrevCols) * _this3.legendDim.heightOfRow > _this3.viewBoxDim.y + _this3.legendHeight;\n          var plottedEvenBalanceOfItemsBtwnCols = i >= numElemsInCol * currentCol;\n          if (exceededCurrentCol || plottedEvenBalanceOfItemsBtwnCols) {\n            colSpacing = (_this3.legendDim.colSpace + _this3.legendDim.ptRadius * 2 + _this3.legendDim.ptToTextSpace) * currentCol;\n            numItemsInPrevCols = i;\n            currentCol++;\n          }\n\n          var totalItemsSpacingExceedLegendArea = legendStartY + (i - numItemsInPrevCols) * _this3.legendDim.heightOfRow > _this3.viewBoxDim.y + _this3.legendHeight;\n          if (totalItemsSpacingExceedLegendArea) {\n            break;\n          }\n        }\n\n        var li = itemsArray[i];\n        if (li.isDraggedPt) {\n          li.x = _this3.legendDim.x + _this3.legendDim.leftPadding + colSpacing;\n          li.y = legendStartY + (i - numItemsInPrevCols) * _this3.legendDim.heightOfRow + _this3.legendDim.vertPtPadding;\n        } else {\n          li.cx = _this3.legendDim.x + _this3.legendDim.leftPadding + colSpacing + li.r;\n          li.cy = legendStartY + (i - numItemsInPrevCols) * _this3.legendDim.heightOfRow;\n          li.x = li.cx + _this3.legendDim.ptToTextSpace;\n          li.y = li.cy + li.r;\n        }\n        result.push(i++);\n      }\n      return result;\n    }();\n  };\n\n  PlotData.prototype.setupLegendGroupsAndPts = function setupLegendGroupsAndPts() {\n    if (this.legendPts.length > 0 && this.legendShow === true) {\n      var totalLegendItems = this.legendGroups.length + this.legendPts.length;\n      var legendItemArray = [];\n      var i = 0;\n      var j = 0;\n\n      // KZ TODO possibly the worst array concat ive ever seen\n      while (i < totalLegendItems) {\n        if (i < this.legendGroups.length) {\n          legendItemArray.push(this.legendGroups[i]);\n        } else {\n          j = i - this.legendGroups.length;\n          legendItemArray.push(this.legendPts[j]);\n        }\n        i++;\n      }\n\n      return this.setLegendItemsPositions(totalLegendItems, legendItemArray, this.legendDim.cols);\n    } else if (this.legendPts.length > 0 && this.legendShow === false) {\n      return this.setLegendItemsPositions(this.legendPts.length, this.legendPts, this.legendDim.cols);\n    } else {\n      return this.setLegendItemsPositions(this.legendGroups.length, this.legendGroups, this.legendDim.cols);\n    }\n  };\n\n  PlotData.prototype.resizedAfterLegendGroupsDrawn = function resizedAfterLegendGroupsDrawn() {\n    var initWidth = this.viewBoxDim.width;\n\n    var totalLegendItems = this.legendShow ? this.legendGroups.length + this.legendPts.length : this.legendPts.length;\n    var legendGrpsTextMax = this.legendGroups.length > 0 && this.legendShow ? _.maxBy(this.legendGroups, function (e) {\n      return e.width;\n    }).width : 0;\n    var legendPtsTextMax = this.legendPts.length > 0 ? _.maxBy(this.legendPts, function (e) {\n      return e.width;\n    }).width : 0;\n\n    var maxTextWidth = _.max([legendGrpsTextMax, legendPtsTextMax]);\n\n    var spacingAroundMaxTextWidth = this.legendDim.leftPadding + this.legendDim.ptRadius * 2 + this.legendDim.rightPadding + this.legendDim.ptToTextSpace;\n\n    var bubbleLeftRightPadding = this.legendDim.leftPadding + this.legendDim.rightPadding;\n\n    this.legendDim.cols = Math.ceil(totalLegendItems * this.legendDim.heightOfRow / this.legendHeight);\n    this.legendDim.width = maxTextWidth * this.legendDim.cols + spacingAroundMaxTextWidth + this.legendDim.centerPadding * (this.legendDim.cols - 1);\n\n    var bubbleTitleWidth = this.legendBubblesTitle != null ? this.legendBubblesTitle[0].width : undefined;\n    this.legendDim.width = _.max([this.legendDim.width, bubbleTitleWidth + bubbleLeftRightPadding, this.legendBubblesMaxWidth + bubbleLeftRightPadding]);\n\n    this.legendDim.colSpace = maxTextWidth;\n\n    this.viewBoxDim.width = this.viewBoxDim.svgWidth - this.legendDim.width - this.viewBoxDim.x - this.axisDimensionText.rowMaxWidth;\n    this.legendDim.x = this.viewBoxDim.x + this.viewBoxDim.width;\n\n    return initWidth !== this.viewBoxDim.width;\n  };\n\n  PlotData.prototype.isOutsideViewBox = function isOutsideViewBox(lab) {\n    var left = lab.x - lab.width / 2;\n    var right = lab.x + lab.width / 2;\n    var top = lab.y - lab.height;\n    var bot = lab.y;\n\n    if (left < this.viewBoxDim.x || right > this.viewBoxDim.x + this.viewBoxDim.width || top < this.viewBoxDim.y || bot > this.viewBoxDim.y + this.viewBoxDim.height) {\n      return true;\n    }\n    return false;\n  };\n\n  PlotData.prototype.isLegendPtOutsideViewBox = function isLegendPtOutsideViewBox(lab) {\n    var left = lab.x;\n    var right = lab.x + lab.width;\n    var top = lab.y - lab.height;\n    var bot = lab.y;\n\n    if (left < this.viewBoxDim.x || right > this.viewBoxDim.x + this.viewBoxDim.width || top < this.viewBoxDim.y || bot > this.viewBoxDim.y + this.viewBoxDim.height) {\n      return true;\n    }\n    return false;\n  };\n\n  PlotData.prototype.addElemToLegend = function addElemToLegend(id) {\n    var checkId = function checkId(e) {\n      return e.id === id;\n    };\n    var movedPt = _.remove(this.pts, checkId);\n    var movedLab = _.remove(this.lab, checkId);\n    this.legendPts.push({\n      id: id,\n      pt: movedPt[0],\n      lab: movedLab[0],\n      anchor: 'start',\n      text: movedLab[0].text + ' (' + movedPt[0].labelX + ', ' + movedPt[0].labelY + ')',\n      color: movedPt[0].color,\n      isDraggedPt: true\n    });\n    //    console.log(\"pushed legendPt : #{JSON.stringify(@legendPts[@legendPts.length-1])}\")\n\n    this.outsidePlotPtsId.push(id);\n    this.normalizeData();\n    this.getPtsAndLabs('PlotData.addElemToLegend');\n    this.setupLegendGroupsAndPts();\n    return this.legendRequiresRedraw = true;\n  };\n\n  PlotData.prototype.removeElemFromLegend = function removeElemFromLegend(id) {\n    var checkId = function checkId(e) {\n      return e.id === id;\n    };\n    var legendPt = _.remove(this.legendPts, checkId);\n    this.pts.push(legendPt.pt);\n    this.lab.push(legendPt.lab);\n\n    _.remove(this.outsidePlotPtsId, function (i) {\n      return i === id;\n    });\n    _.remove(this.outsidePlotCondensedPts, function (i) {\n      return i.dataId === id;\n    });\n\n    this.normalizeData();\n    this.getPtsAndLabs('PlotData.removeElemFromLegend');\n    return this.setupLegendGroupsAndPts();\n  };\n\n  return PlotData;\n}();\n\nmodule.exports = PlotData;\n\n},{}]},{},[1])(1)\n});\n\n"],"sourceRoot":"/source/"}