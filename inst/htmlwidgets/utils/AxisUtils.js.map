{"version":3,"file":"utils/AxisUtils.es6.js","names":[],"mappings":"","sources":["utils/AxisUtils.es6.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.AxisUtils = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* global Utils */\n// import Utils from './Utils.es6';\n\n/* To Refactor:\n *  * marker leader lines + labels can surely be grouped or at least the lines can be derived at presentation time\n */\n\nvar AxisUtils = function () {\n  function AxisUtils() {\n    _classCallCheck(this, AxisUtils);\n  }\n\n  // Calc tick increments - http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axis\n  AxisUtils._getTickRange = function _getTickRange(max, min) {\n    var maxTicks = 8;\n    var range = max - min;\n    var unroundedTickSize = range / (maxTicks - 1);\n\n    var pow10x = 10 ** Math.ceil(Math.log(unroundedTickSize) / Math.LN10 - 1);\n    var roundedTickRange = Math.ceil(unroundedTickSize / pow10x) * pow10x;\n    return roundedTickRange;\n  };\n\n  AxisUtils._between = function _between(num, min, max) {\n    return num >= min && num <= max;\n  };\n\n  AxisUtils._normalizeXCoords = function _normalizeXCoords(data, Xcoord) {\n    var viewBoxDim = data.viewBoxDim;\n\n    return (Xcoord - data.minX) / (data.maxX - data.minX) * viewBoxDim.width + viewBoxDim.x;\n  };\n\n  AxisUtils._normalizeYCoords = function _normalizeYCoords(data, Ycoord) {\n    var viewBoxDim = data.viewBoxDim;\n\n    return -(Ycoord - data.minY) / (data.maxY - data.minY) * viewBoxDim.height + viewBoxDim.y + viewBoxDim.height;\n  };\n\n  // TODO KZ calculation of x axis and y axis are independent ? If so, then split into a reusable function\n\n\n  AxisUtils.getAxisDataArrays = function getAxisDataArrays(plot, data, viewBoxDim) {\n    // exit if all points have been dragged off plot\n    if (!(data.len > 0)) {\n      return {};\n    }\n\n    var dimensionMarkerStack = [];\n    var dimensionMarkerLeaderStack = [];\n    var dimensionMarkerLabelStack = [];\n\n    var pushDimensionMarker = function pushDimensionMarker(type, x1, y1, x2, y2, label) {\n      var leaderLineLen = plot.axisLeaderLineLength;\n      var labelHeight = _.max([plot.axisDimensionText.rowMaxHeight, plot.axisDimensionText.colMaxHeight]);\n      var xDecimals = plot.xDecimals,\n          yDecimals = plot.yDecimals,\n          xPrefix = plot.xPrefix,\n          yPrefix = plot.yPrefix,\n          xSuffix = plot.xSuffix,\n          ySuffix = plot.ySuffix;\n\n\n      if (type === 'col') {\n        dimensionMarkerLeaderStack.push({\n          x1: x1,\n          y1: y2,\n          x2: x1,\n          y2: y2 + leaderLineLen\n        });\n        dimensionMarkerLabelStack.push({\n          x: x1,\n          y: y2 + leaderLineLen + labelHeight,\n          label: Utils.getFormattedNum(label, xDecimals, xPrefix, xSuffix),\n          anchor: 'middle',\n          type: type\n        });\n      }\n\n      if (type === 'row') {\n        dimensionMarkerLeaderStack.push({\n          x1: x1 - leaderLineLen,\n          y1: y1,\n          x2: x1,\n          y2: y2\n        });\n        dimensionMarkerLabelStack.push({\n          x: x1 - leaderLineLen,\n          y: y2 + labelHeight / 3,\n          label: Utils.getFormattedNum(label, yDecimals, yPrefix, ySuffix),\n          anchor: 'end',\n          type: type\n        });\n      }\n    };\n\n    // TODO KZ (another) Unecessary call to calculateMinMax ??\n    data.calculateMinMax();\n\n    var ticksX = null;\n    var ticksY = null;\n\n    if (Utils.isNum(plot.xBoundsUnitsMajor)) {\n      ticksX = plot.xBoundsUnitsMajor / 2;\n    } else {\n      ticksX = this._getTickRange(data.maxX, data.minX);\n    }\n\n    if (Utils.isNum(plot.yBoundsUnitsMajor)) {\n      ticksY = plot.yBoundsUnitsMajor / 2;\n    } else {\n      ticksY = this._getTickRange(data.maxY, data.minY);\n    }\n\n    // Compute origins if they are within bounds\n\n    var originAxis = [];\n    var yCoordOfXAxisOrigin = this._normalizeYCoords(data, 0);\n    if (yCoordOfXAxisOrigin <= viewBoxDim.y + viewBoxDim.height && yCoordOfXAxisOrigin >= viewBoxDim.y) {\n      var xAxisOrigin = {\n        x1: viewBoxDim.x,\n        y1: yCoordOfXAxisOrigin,\n        x2: viewBoxDim.x + viewBoxDim.width,\n        y2: yCoordOfXAxisOrigin\n      };\n      pushDimensionMarker('row', xAxisOrigin.x1, xAxisOrigin.y1, xAxisOrigin.x2, xAxisOrigin.y2, 0);\n      if (data.minY !== 0 && data.maxY !== 0) {\n        originAxis.push(xAxisOrigin);\n      }\n    }\n\n    var xCoordOfYAxisOrigin = this._normalizeXCoords(data, 0);\n    if (xCoordOfYAxisOrigin >= viewBoxDim.x && xCoordOfYAxisOrigin <= viewBoxDim.x + viewBoxDim.width) {\n      var yAxisOrigin = {\n        x1: xCoordOfYAxisOrigin,\n        y1: viewBoxDim.y,\n        x2: xCoordOfYAxisOrigin,\n        y2: viewBoxDim.y + viewBoxDim.height\n      };\n      pushDimensionMarker('col', yAxisOrigin.x1, yAxisOrigin.y1, yAxisOrigin.x2, yAxisOrigin.y2, 0);\n      if (data.minX !== 0 && data.maxX !== 0) {\n        originAxis.push(yAxisOrigin);\n      }\n    }\n\n    // calculate number of dimension markers\n\n    var colsPositive = 0;\n    var colsNegative = 0;\n    if (this._between(0, data.minX, data.maxX)) {\n      colsPositive = data.maxX / ticksX - 1;\n      colsNegative = Math.abs(data.minX / ticksX) - 1;\n    } else {\n      var numColumns = (data.maxX - data.minX) / ticksX;\n      if (data.minX < 0) {\n        colsNegative = numColumns;\n        colsPositive = 0;\n      } else {\n        colsNegative = 0;\n        colsPositive = numColumns;\n      }\n    }\n\n    var rowsPositive = 0;\n    var rowsNegative = 0;\n    if (this._between(0, data.minY, data.maxY)) {\n      rowsPositive = Math.abs(data.minY / ticksY) - 1;\n      rowsNegative = data.maxY / ticksY - 1;\n    } else {\n      var numRows = (data.maxY - data.minY) / ticksY;\n      if (data.minY < 0) {\n        rowsNegative = 0;\n        rowsPositive = numRows;\n      } else {\n        rowsNegative = numRows;\n        rowsPositive = 0;\n      }\n    }\n\n    var i = 0;\n    while (i < Math.max(colsPositive, colsNegative)) {\n      var val = void 0,\n          x1 = void 0,\n          x2 = void 0,\n          y1 = void 0,\n          y2 = null;\n\n      if (i < colsPositive) {\n        val = (i + 1) * ticksX;\n        if (!this._between(0, data.minX, data.maxX)) {\n          val = data.minX + i * ticksX;\n        }\n        x1 = this._normalizeXCoords(data, val);\n        y1 = viewBoxDim.y;\n        x2 = this._normalizeXCoords(data, val);\n        y2 = viewBoxDim.y + viewBoxDim.height;\n\n        dimensionMarkerStack.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\n        if (i % 2) {\n          pushDimensionMarker('col', x1, y1, x2, y2, val.toPrecision(14));\n        }\n      }\n\n      if (i < colsNegative) {\n        val = -(i + 1) * ticksX;\n        x1 = this._normalizeXCoords(data, val);\n        y1 = viewBoxDim.y;\n        x2 = this._normalizeXCoords(data, val);\n        y2 = viewBoxDim.y + viewBoxDim.height;\n        dimensionMarkerStack.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\n        if (i % 2) {\n          pushDimensionMarker('col', x1, y1, x2, y2, val.toPrecision(14));\n        }\n      }\n      i++;\n    }\n\n    i = 0;\n    while (i < Math.max(rowsPositive, rowsNegative)) {\n      var _val = void 0,\n          _x = void 0,\n          _x2 = void 0,\n          _y = void 0,\n          _y2 = null;\n\n      if (i < rowsPositive) {\n        _val = -(i + 1) * ticksY;\n        _x = viewBoxDim.x;\n        _y = this._normalizeYCoords(data, _val);\n        _x2 = viewBoxDim.x + viewBoxDim.width;\n        _y2 = this._normalizeYCoords(data, _val);\n        dimensionMarkerStack.push({ x1: _x, y1: _y, x2: _x2, y2: _y2 });\n        if (i % 2) {\n          pushDimensionMarker('row', _x, _y, _x2, _y2, _val.toPrecision(14));\n        }\n      }\n\n      if (i < rowsNegative) {\n        _val = (i + 1) * ticksY;\n        if (!this._between(0, data.minY, data.maxY)) {\n          _val = data.minY + i * ticksY;\n        }\n        _x = viewBoxDim.x;\n        _y = this._normalizeYCoords(data, _val);\n        _x2 = viewBoxDim.x + viewBoxDim.width;\n        _y2 = this._normalizeYCoords(data, _val);\n        dimensionMarkerStack.push({ x1: _x, y1: _y, x2: _x2, y2: _y2 });\n        if (i % 2) {\n          pushDimensionMarker('row', _x, _y, _x2, _y2, _val.toPrecision(14));\n        }\n      }\n      i++;\n    }\n\n    return {\n      gridOrigin: originAxis,\n      gridLines: dimensionMarkerStack,\n      axisLeader: dimensionMarkerLeaderStack,\n      axisLeaderLabel: dimensionMarkerLabelStack\n    };\n  };\n\n  return AxisUtils;\n}();\n\nmodule.exports = AxisUtils;\n\n},{}]},{},[1])(1)\n});\n\n"],"sourceRoot":"/source/"}